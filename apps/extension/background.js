/**
 * Smart Time Tracker - Background Service Worker (Manifest V3)
 */

// Sync every 30 seconds
chrome.alarms.create("syncLogs", { periodInMinutes: 0.5 });

function logPrefix() {
  return "[Smart Time Tracker][bg]";
}

function normalizeUserId(value) {
  if (typeof value !== "string") return "";
  return value.trim();
}

function normalizeToken(value) {
  if (typeof value !== "string") return "";
  return value.trim();
}

function isValidToken(value) {
  const t = normalizeToken(value);
  return t.length >= 20;
}

function isValidUserId(value) {
  const id = normalizeUserId(value);
  return id.length >= 6;
}

// ---- Messages (from content script) ----
chrome.runtime.onMessage.addListener((request, sender, sendResponse) => {
  if (request && request.type === "SET_USER_ID") {
    const incoming = normalizeUserId(request.user_id);

    if (!isValidUserId(incoming)) {
      sendResponse({ success: false, error: "Invalid user_id" });
      return false;
    }

    chrome.storage.local.get(["user_id"], (result) => {
      // Just save it
      chrome.storage.local.set({ user_id: incoming }, () => {
        console.log(logPrefix(), "User ID updated:", incoming);
        sendResponse({ success: true });
      });
    });
    return true;
  }
  return false;
});

// ---- State Management (Persisted) ----
// In MV3, global variables are volatile. We must use storage.

async function getActiveSession() {
  const data = await chrome.storage.local.get(["activeSession"]);
  return data.activeSession || null;
}

async function setActiveSession(session) {
  // session: { domain, startTime } or null
  if (session) {
    await chrome.storage.local.set({ activeSession: session });
  } else {
    await chrome.storage.local.remove(["activeSession"]);
  }
}

// ---- Tracking: tab + idle ----
chrome.tabs.onActivated.addListener((activeInfo) => {
  handleTabChange(activeInfo.tabId);
});

chrome.tabs.onUpdated.addListener((tabId, changeInfo) => {
  if (changeInfo && changeInfo.url) {
    handleTabChange(tabId);
  }
});

chrome.idle.onStateChanged.addListener((newState) => {
  if (newState !== "active") {
    closeCurrentSession();
  } else {
    chrome.tabs.query({ active: true, currentWindow: true }, (tabs) => {
      if (tabs && tabs[0]) handleTabChange(tabs[0].id);
    });
  }
});

async function handleTabChange(newTabId) {
  await closeCurrentSession();

  try {
    const tab = await chrome.tabs.get(newTabId);
    if (!tab || !tab.url) return;

    // Ignore internal pages
    if (tab.url.startsWith('chrome://') || tab.url.startsWith('edge://') || tab.url.startsWith('about:')) return;

    const domain = new URL(tab.url).hostname;

    // Start new session
    const session = {
      domain,
      startTime: Date.now()
    };
    await setActiveSession(session);

    console.log(logPrefix(), "Started tracking:", domain);
  } catch (e) {
    console.error(logPrefix(), "Error accessing tab:", e);
  }
}

async function closeCurrentSession() {
  const session = await getActiveSession();
  if (!session) return;

  const { domain, startTime } = session;
  if (!domain || !startTime) return;

  const duration = (Date.now() - startTime) / 1000;
  if (duration < 1) return; // Ignore brief switches

  const log = {
    domain,
    startTime: new Date(startTime).toISOString(),
    duration,
  };

  try {
    const data = await chrome.storage.local.get(["logs"]);
    const logs = data && Array.isArray(data.logs) ? data.logs : [];
    logs.push(log);
    await chrome.storage.local.set({ logs });

    // Clear active session so we don't double-log
    await setActiveSession(null);

    // Trigger near-immediate sync
    chrome.alarms.create("syncLogs", { when: Date.now() + 100 });

    console.log(logPrefix(), "Logged:", log);
  } catch (e) {
    console.error(logPrefix(), "Failed to store log locally:", e);
  }
}

// ---- Sync logs to server ----
chrome.alarms.onAlarm.addListener((alarm) => {
  if (!alarm || alarm.name !== "syncLogs") return;

  chrome.storage.local.get(
    ["logs", "extension_token", "user_id"],
    async (result) => {
      const logs = result && Array.isArray(result.logs) ? result.logs : [];
      const extension_token = normalizeToken(result && result.extension_token);
      const user_id = normalizeUserId(result && result.user_id); // legacy fallback only

      if (logs.length === 0) return;

      // Preferred: token-based auth
      if (!isValidToken(extension_token)) {
        // Legacy fallback: if you still want to support user_id uploads, keep this branch.
        // Otherwise, you can remove the fallback and simply return.
        if (!isValidUserId(user_id)) {
          console.warn(
            logPrefix(),
            "No valid extension_token yet (and no valid legacy user_id); skipping sync and keeping logs locally.",
          );
          return;
        }

        console.warn(
          logPrefix(),
          "No valid extension_token yet; falling back to legacy user_id upload.",
        );
      }

      try {
        const headers = { "Content-Type": "application/json" };

        // If token exists, use Authorization header and omit user_id from body.
        // If token is missing, fall back to legacy body { logs, user_id }.
        const useToken = isValidToken(extension_token);

        if (useToken) {
          headers.Authorization = `Bearer ${extension_token}`;
        }

        const body = useToken ? { logs } : { logs, user_id };

        console.log(
          logPrefix(),
          "Preparing to sync. Payload:",
          JSON.stringify(body),
        );

        const response = await fetch("http://localhost:3000/api/logs", {
          method: "POST",
          headers,
          body: JSON.stringify(body),
        });

        if (response.ok) {
          console.log(
            logPrefix(),
            "Synced logs to server. Status:",
            response.status,
          );
          chrome.storage.local.set({ logs: [] });
        } else {
          const text = await response.text().catch(() => "");
          console.warn(
            logPrefix(),
            "Server responded non-OK; keeping logs to retry. Status:",
            response.status,
            {
              body: text,
            },
          );
        }
      } catch (error) {
        console.error(
          logPrefix(),
          "Failed to sync. Server likely down or blocking.",
          error,
        );
        // keep logs for retry
      }
    },
  );
});
